#!/usr/bin/env python3

# Generated by chatgpt!! Use with caution!

import argparse
import itertools
import subprocess
import sys
from collections import Counter


def collect_tests(test_file):
    """
    Collects all tests from the specified test file using 'pytest --collect-only -q'.
    Filters out lines like 'N tests collected in Xs'.
    Returns a list of valid test IDs (e.g. "tests/test_file.py::test_foo").
    """
    command = ["pytest", test_file, "--collect-only", "-q"]
    result = subprocess.run(command, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True)
    if result.returncode != 0:
        print(f"Error collecting tests from {test_file}:\n{result.stderr}")
        return []

    tests = []
    for line in result.stdout.splitlines():
        line = line.strip()
        # Keep lines that look like test IDs containing '::'
        # Skip lines such as 'N tests collected in Xs'
        if "::" in line:
            tests.append(line)
    return tests


def run_pytest(test_pair):
    """
    Runs pytest with the given pair of tests.
    Returns True if the test pair fails (non-zero exit code), False otherwise.
    """
    command = ["pytest", "-q"] + list(test_pair)
    result = subprocess.run(command, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True)
    return result.returncode != 0


def test_all_pairs(tests, verbose=False, progress=False):
    """
    1. Uses permutations(tests, 2) so every *ordered* pair is tested: (A,B) and (B,A).
    2. Records whether each direction fails.
    3. Prints a final summary in canonical form (A < B). For each distinct A,B:
       - "And Reversed" if both directions fail
       - "Only" if exactly one direction fails
       - No line if neither direction fails
    4. Calculates and prints the top 3 problematic tests by frequency in failing pairs.
    """

    # Prepare a dictionary to track failures for each *unordered* pair.
    fail_info = {}

    # Counter to track how often each test appears in failing pairs.
    test_failure_count = Counter()

    # Generate permutations => ordered pairs
    pairs = list(itertools.permutations(tests, 2))
    total_pairs = len(pairs)
    tested_count = 0
    num_tests = len(tests)

    for A, B in pairs:
        tested_count += 1

        # Possibly show progress
        if verbose:
            print(f"Testing pair: ({A}, {B})")
        elif progress:
            print(f"\rTested {tested_count}/{total_pairs} pairs ({num_tests} tests)", end="", flush=True)

        # Test the pair
        failed = run_pytest((A, B))

        # Build canonical key
        if A < B:
            key = (A, B)
            forward_index, reverse_index = 0, 1
        else:
            key = (B, A)
            forward_index, reverse_index = 1, 0

        if key not in fail_info:
            fail_info[key] = [False, False]

        if failed:
            fail_info[key][forward_index] = True
            test_failure_count[A] += 1
            test_failure_count[B] += 1

            if verbose:
                print(f"  Failing pair: ({A}, {B})")

    if progress:
        # End the line after the progress loop
        print()

    # Print the final summary in sorted(key) order
    print("\n=== Summary of Failing Test Pairs (canonical order) ===")
    any_fail = False
    for pair_key in sorted(fail_info.keys()):
        fwd_fail, rev_fail = fail_info[pair_key]
        if fwd_fail and rev_fail:
            print(f"{pair_key}: And Reversed")
            any_fail = True
        elif fwd_fail ^ rev_fail:
            print(f"{pair_key}: Only")
            any_fail = True

    if not any_fail:
        print("No failing pairs found.")

    # Print top 3 problematic tests
    print("\n=== Top 3 Problematic Tests ===")
    for test, count in test_failure_count.most_common(3):
        print(f"{test}: {count} failures")


def main():
    parser = argparse.ArgumentParser(
        description="Test all ordered pairs of tests from a given file.",
        epilog="Example usage:\n"
        "  python test_pairs.py tests/test_file.py --progress\n"
        "  python test_pairs.py tests/test_file.py --verbose\n",
        formatter_class=argparse.RawTextHelpFormatter,
    )
    parser.add_argument("test_file", help="Path to the test file (e.g. tests/test_file.py)")
    parser.add_argument("--verbose", action="store_true", help="Show each test pair and immediate fails.")
    parser.add_argument("--progress", action="store_true", help="Show a single-line progress indicator.")
    args = parser.parse_args()

    tests = collect_tests(args.test_file)
    if not tests:
        print(f"No valid test IDs found in {args.test_file}. Exiting.")
        sys.exit(1)

    if args.verbose:
        print(f"Collected {len(tests)} test(s) from {args.test_file}.\n")

    # Run permutations
    test_all_pairs(tests, verbose=args.verbose, progress=args.progress)


if __name__ == "__main__":
    main()
